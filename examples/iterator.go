// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package iter

// IterableForInt describes a struct that can be iterated over.
type IterableForInt interface {
	Next() OptionForInt
}

// IteratorForInt embeds an Iterable and provides util functions for it.
type IteratorForInt struct {
	iter IterableForInt
}

// Iterator implements Iterable.
var _ IterableForInt = IteratorForInt{}

// Next returns the next element of the Iterator.
func (i IteratorForInt) Next() OptionForInt {
	return i.iter.Next()
}

// AdvanceBy calls Next n times.
// It returns an error if it reached the end of the Iterator
// before it finished to iterate.
func (i IteratorForInt) AdvanceBy(n uint) error {
	for k := uint(0); k < n; k++ {
		if i.Next().IsNone() {
			return &errAdvanceBy{}
		}
	}

	return nil
}

// Nth returns the nth element of the Iterator.
func (i IteratorForInt) Nth(n uint) OptionForInt {
	i.AdvanceBy(n)
	return i.Next()
}

// Skip the next n iterations.
func (i IteratorForInt) Skip(n uint) IteratorForInt {
	i.AdvanceBy(n)
	return i
}

// Collect returns a slice containing the elements of the Iterator.
func (i IteratorForInt) Collect() []int {
	collected := []int{}

	item := i.Next()
	for item.IsSome() {
		collected = append(collected, item.Unwrap())

		item = i.Next()
	}

	return collected
}

// FoldFirst folds over the Iterator, using its first element as the accumulator initial value.
func (i IteratorForInt) FoldFirst(reducer func(acc, item int) int) OptionForInt {
	first := i.Next()
	if first.IsNone() {
		return NoneInt()
	}

	return SomeInt(i.FoldForInt(first.Unwrap(), reducer))
}

// Count returns the number of elements in the Iterator.
func (i IteratorForInt) Count() uint {
	return i.FoldForUint(uint(0), func(acc uint, item int) uint {
		return acc + 1
	})
}

// Last returns the last element of the Iterator.
func (i IteratorForInt) Last() OptionForInt {
	return i.FoldForOptionForInt(NoneInt(), func(acc OptionForInt, item int) OptionForInt {
		return SomeInt(item)
	})
}

// ForEach runs a callback for every element of the iterator.
func (i IteratorForInt) ForEach(callback func(item int)) {
	i.FoldForEmpty(Empty{}, func(acc Empty, item int) Empty {
		callback(item)
		return acc
	})
}

// All checks if all the elements of the Iterator validates a predicate.
func (i IteratorForInt) All(predicate func(item int) bool) bool {
	_, ok := i.TryFoldForEmpty(Empty{}, func(acc Empty, item int) (Empty, bool) {
		return acc, predicate(item)
	})
	return ok
}

// Any checks if at least one element of the Iterator validates a predicate.
func (i IteratorForInt) Any(predicate func(item int) bool) bool {
	_, ok := i.TryFoldForEmpty(Empty{}, func(acc Empty, item int) (Empty, bool) {
		return acc, !predicate(item)
	})
	return !ok
}

// Find returns the first element of the Iterator that validates a predicate.
func (i IteratorForInt) Find(predicate func(item int) bool) OptionForInt {
	r, ok := i.TryFoldForOptionForInt(NoneInt(), func(acc OptionForInt, item int) (OptionForInt, bool) {
		return SomeInt(item), !predicate(item)
	})

	if ok {
		return NoneInt()
	}

	return r
}

// Position returns the position of the first element of the Iterator that validates a predicate.
func (i IteratorForInt) Position(predicate func(item int) bool) OptionForUint {
	r, ok := i.TryFoldForUint(uint(0), func(acc uint, item int) (uint, bool) {
		if predicate(item) {
			return acc, false
		}

		return acc + 1, true
	})

	if ok {
		return NoneUint()
	}

	return SomeUint(r)
}

// SkipWhile skips the next elements until it reaches one which validates predicate.
func (i IteratorForInt) SkipWhile(predicate func(item int) bool) IteratorForInt {
	i.Find(predicate)

	return i
}

// Map returns a new Iterator applying a mapper function to every element.
func (i IteratorForInt) Map(mapper func(item int) int) IteratorForInt {
	return IteratorForInt{iter: &mapIterableForInt{mapper: mapper, iter: i.iter}}
}

// Chain returns a new Iterator sequentially joining the two it was built on.
func (i IteratorForInt) Chain(iter IteratorForInt) IteratorForInt {
	return IteratorForInt{iter: &chainForInt{first: i.iter, second: iter.iter, flag: false}}
}

// TakeWhile returns a new Iterator yielding elements until predicate becomes false.
func (i IteratorForInt) TakeWhile(predicate func(item int) bool) IteratorForInt {
	return IteratorForInt{iter: &takeWhileForInt{iter: i.iter, predicate: predicate, flag: false}}
}

// Take returns a new Iterator yielding only the n next elements.
func (i IteratorForInt) Take(n uint) IteratorForInt {
	return IteratorForInt{iter: &takeForInt{iter: i.iter, count: 0, max: n, flag: false}}
}

// Filter returns a new Iterator yielding only elements validating a predicate.
func (i IteratorForInt) Filter(predicate func(item int) bool) IteratorForInt {
	return IteratorForInt{iter: &filterForInt{iter: i, predicate: predicate}}
}

// IterableForString describes a struct that can be iterated over.
type IterableForString interface {
	Next() OptionForString
}

// IteratorForString embeds an Iterable and provides util functions for it.
type IteratorForString struct {
	iter IterableForString
}

// Iterator implements Iterable.
var _ IterableForString = IteratorForString{}

// Next returns the next element of the Iterator.
func (i IteratorForString) Next() OptionForString {
	return i.iter.Next()
}

// AdvanceBy calls Next n times.
// It returns an error if it reached the end of the Iterator
// before it finished to iterate.
func (i IteratorForString) AdvanceBy(n uint) error {
	for k := uint(0); k < n; k++ {
		if i.Next().IsNone() {
			return &errAdvanceBy{}
		}
	}

	return nil
}

// Nth returns the nth element of the Iterator.
func (i IteratorForString) Nth(n uint) OptionForString {
	i.AdvanceBy(n)
	return i.Next()
}

// Skip the next n iterations.
func (i IteratorForString) Skip(n uint) IteratorForString {
	i.AdvanceBy(n)
	return i
}

// Collect returns a slice containing the elements of the Iterator.
func (i IteratorForString) Collect() []string {
	collected := []string{}

	item := i.Next()
	for item.IsSome() {
		collected = append(collected, item.Unwrap())

		item = i.Next()
	}

	return collected
}

// FoldFirst folds over the Iterator, using its first element as the accumulator initial value.
func (i IteratorForString) FoldFirst(reducer func(acc, item string) string) OptionForString {
	first := i.Next()
	if first.IsNone() {
		return NoneString()
	}

	return SomeString(i.FoldForString(first.Unwrap(), reducer))
}

// Count returns the number of elements in the Iterator.
func (i IteratorForString) Count() uint {
	return i.FoldForUint(uint(0), func(acc uint, item string) uint {
		return acc + 1
	})
}

// Last returns the last element of the Iterator.
func (i IteratorForString) Last() OptionForString {
	return i.FoldForOptionForString(NoneString(), func(acc OptionForString, item string) OptionForString {
		return SomeString(item)
	})
}

// ForEach runs a callback for every element of the iterator.
func (i IteratorForString) ForEach(callback func(item string)) {
	i.FoldForEmpty(Empty{}, func(acc Empty, item string) Empty {
		callback(item)
		return acc
	})
}

// All checks if all the elements of the Iterator validates a predicate.
func (i IteratorForString) All(predicate func(item string) bool) bool {
	_, ok := i.TryFoldForEmpty(Empty{}, func(acc Empty, item string) (Empty, bool) {
		return acc, predicate(item)
	})
	return ok
}

// Any checks if at least one element of the Iterator validates a predicate.
func (i IteratorForString) Any(predicate func(item string) bool) bool {
	_, ok := i.TryFoldForEmpty(Empty{}, func(acc Empty, item string) (Empty, bool) {
		return acc, !predicate(item)
	})
	return !ok
}

// Find returns the first element of the Iterator that validates a predicate.
func (i IteratorForString) Find(predicate func(item string) bool) OptionForString {
	r, ok := i.TryFoldForOptionForString(NoneString(), func(acc OptionForString, item string) (OptionForString, bool) {
		return SomeString(item), !predicate(item)
	})

	if ok {
		return NoneString()
	}

	return r
}

// Position returns the position of the first element of the Iterator that validates a predicate.
func (i IteratorForString) Position(predicate func(item string) bool) OptionForUint {
	r, ok := i.TryFoldForUint(uint(0), func(acc uint, item string) (uint, bool) {
		if predicate(item) {
			return acc, false
		}

		return acc + 1, true
	})

	if ok {
		return NoneUint()
	}

	return SomeUint(r)
}

// SkipWhile skips the next elements until it reaches one which validates predicate.
func (i IteratorForString) SkipWhile(predicate func(item string) bool) IteratorForString {
	i.Find(predicate)

	return i
}

// Map returns a new Iterator applying a mapper function to every element.
func (i IteratorForString) Map(mapper func(item string) string) IteratorForString {
	return IteratorForString{iter: &mapIterableForString{mapper: mapper, iter: i.iter}}
}

// Chain returns a new Iterator sequentially joining the two it was built on.
func (i IteratorForString) Chain(iter IteratorForString) IteratorForString {
	return IteratorForString{iter: &chainForString{first: i.iter, second: iter.iter, flag: false}}
}

// TakeWhile returns a new Iterator yielding elements until predicate becomes false.
func (i IteratorForString) TakeWhile(predicate func(item string) bool) IteratorForString {
	return IteratorForString{iter: &takeWhileForString{iter: i.iter, predicate: predicate, flag: false}}
}

// Take returns a new Iterator yielding only the n next elements.
func (i IteratorForString) Take(n uint) IteratorForString {
	return IteratorForString{iter: &takeForString{iter: i.iter, count: 0, max: n, flag: false}}
}

// Filter returns a new Iterator yielding only elements validating a predicate.
func (i IteratorForString) Filter(predicate func(item string) bool) IteratorForString {
	return IteratorForString{iter: &filterForString{iter: i, predicate: predicate}}
}
