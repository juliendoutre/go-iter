// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package iter

// FoldForInt applies a reducer to the Iterator.
func (i IteratorForInt) FoldForInt(init int, reducer func(acc int, item int) int) int {
	acc := init

	item := i.Next()
	for item.IsSome() {
		acc = reducer(acc, item.Unwrap())

		item = i.Next()
	}

	return acc
}

// TryFoldForInt folds over the Iterator and stops if it reaches the end of the Iterator or got a Break (bool, interface{}).
func (i IteratorForInt) TryFoldForInt(init int, reducer func(acc int, item int) (int, bool)) (int, bool) {
	acc := init

	item := i.Next()
	for item.IsSome() {
		r, ok := reducer(acc, item.Unwrap())
		if !ok {
			return r, ok
		}

		acc = r
		item = i.Next()
	}

	return acc, true
}

// FoldForUint applies a reducer to the Iterator.
func (i IteratorForInt) FoldForUint(init uint, reducer func(acc uint, item int) uint) uint {
	acc := init

	item := i.Next()
	for item.IsSome() {
		acc = reducer(acc, item.Unwrap())

		item = i.Next()
	}

	return acc
}

// TryFoldForUint folds over the Iterator and stops if it reaches the end of the Iterator or got a Break (bool, interface{}).
func (i IteratorForInt) TryFoldForUint(init uint, reducer func(acc uint, item int) (uint, bool)) (uint, bool) {
	acc := init

	item := i.Next()
	for item.IsSome() {
		r, ok := reducer(acc, item.Unwrap())
		if !ok {
			return r, ok
		}

		acc = r
		item = i.Next()
	}

	return acc, true
}

// FoldForEmpty applies a reducer to the Iterator.
func (i IteratorForInt) FoldForEmpty(init Empty, reducer func(acc Empty, item int) Empty) Empty {
	acc := init

	item := i.Next()
	for item.IsSome() {
		acc = reducer(acc, item.Unwrap())

		item = i.Next()
	}

	return acc
}

// TryFoldForEmpty folds over the Iterator and stops if it reaches the end of the Iterator or got a Break (bool, interface{}).
func (i IteratorForInt) TryFoldForEmpty(init Empty, reducer func(acc Empty, item int) (Empty, bool)) (Empty, bool) {
	acc := init

	item := i.Next()
	for item.IsSome() {
		r, ok := reducer(acc, item.Unwrap())
		if !ok {
			return r, ok
		}

		acc = r
		item = i.Next()
	}

	return acc, true
}

// FoldForString applies a reducer to the Iterator.
func (i IteratorForInt) FoldForString(init string, reducer func(acc string, item int) string) string {
	acc := init

	item := i.Next()
	for item.IsSome() {
		acc = reducer(acc, item.Unwrap())

		item = i.Next()
	}

	return acc
}

// TryFoldForString folds over the Iterator and stops if it reaches the end of the Iterator or got a Break (bool, interface{}).
func (i IteratorForInt) TryFoldForString(init string, reducer func(acc string, item int) (string, bool)) (string, bool) {
	acc := init

	item := i.Next()
	for item.IsSome() {
		r, ok := reducer(acc, item.Unwrap())
		if !ok {
			return r, ok
		}

		acc = r
		item = i.Next()
	}

	return acc, true
}

// FoldForOptionForInt applies a reducer to the Iterator.
func (i IteratorForInt) FoldForOptionForInt(init OptionForInt, reducer func(acc OptionForInt, item int) OptionForInt) OptionForInt {
	acc := init

	item := i.Next()
	for item.IsSome() {
		acc = reducer(acc, item.Unwrap())

		item = i.Next()
	}

	return acc
}

// TryFoldForOptionForInt folds over the Iterator and stops if it reaches the end of the Iterator or got a Break (bool, interface{}).
func (i IteratorForInt) TryFoldForOptionForInt(init OptionForInt, reducer func(acc OptionForInt, item int) (OptionForInt, bool)) (OptionForInt, bool) {
	acc := init

	item := i.Next()
	for item.IsSome() {
		r, ok := reducer(acc, item.Unwrap())
		if !ok {
			return r, ok
		}

		acc = r
		item = i.Next()
	}

	return acc, true
}

// FoldForOptionForString applies a reducer to the Iterator.
func (i IteratorForInt) FoldForOptionForString(init OptionForString, reducer func(acc OptionForString, item int) OptionForString) OptionForString {
	acc := init

	item := i.Next()
	for item.IsSome() {
		acc = reducer(acc, item.Unwrap())

		item = i.Next()
	}

	return acc
}

// TryFoldForOptionForString folds over the Iterator and stops if it reaches the end of the Iterator or got a Break (bool, interface{}).
func (i IteratorForInt) TryFoldForOptionForString(init OptionForString, reducer func(acc OptionForString, item int) (OptionForString, bool)) (OptionForString, bool) {
	acc := init

	item := i.Next()
	for item.IsSome() {
		r, ok := reducer(acc, item.Unwrap())
		if !ok {
			return r, ok
		}

		acc = r
		item = i.Next()
	}

	return acc, true
}

// FoldForInt applies a reducer to the Iterator.
func (i IteratorForString) FoldForInt(init int, reducer func(acc int, item string) int) int {
	acc := init

	item := i.Next()
	for item.IsSome() {
		acc = reducer(acc, item.Unwrap())

		item = i.Next()
	}

	return acc
}

// TryFoldForInt folds over the Iterator and stops if it reaches the end of the Iterator or got a Break (bool, interface{}).
func (i IteratorForString) TryFoldForInt(init int, reducer func(acc int, item string) (int, bool)) (int, bool) {
	acc := init

	item := i.Next()
	for item.IsSome() {
		r, ok := reducer(acc, item.Unwrap())
		if !ok {
			return r, ok
		}

		acc = r
		item = i.Next()
	}

	return acc, true
}

// FoldForUint applies a reducer to the Iterator.
func (i IteratorForString) FoldForUint(init uint, reducer func(acc uint, item string) uint) uint {
	acc := init

	item := i.Next()
	for item.IsSome() {
		acc = reducer(acc, item.Unwrap())

		item = i.Next()
	}

	return acc
}

// TryFoldForUint folds over the Iterator and stops if it reaches the end of the Iterator or got a Break (bool, interface{}).
func (i IteratorForString) TryFoldForUint(init uint, reducer func(acc uint, item string) (uint, bool)) (uint, bool) {
	acc := init

	item := i.Next()
	for item.IsSome() {
		r, ok := reducer(acc, item.Unwrap())
		if !ok {
			return r, ok
		}

		acc = r
		item = i.Next()
	}

	return acc, true
}

// FoldForEmpty applies a reducer to the Iterator.
func (i IteratorForString) FoldForEmpty(init Empty, reducer func(acc Empty, item string) Empty) Empty {
	acc := init

	item := i.Next()
	for item.IsSome() {
		acc = reducer(acc, item.Unwrap())

		item = i.Next()
	}

	return acc
}

// TryFoldForEmpty folds over the Iterator and stops if it reaches the end of the Iterator or got a Break (bool, interface{}).
func (i IteratorForString) TryFoldForEmpty(init Empty, reducer func(acc Empty, item string) (Empty, bool)) (Empty, bool) {
	acc := init

	item := i.Next()
	for item.IsSome() {
		r, ok := reducer(acc, item.Unwrap())
		if !ok {
			return r, ok
		}

		acc = r
		item = i.Next()
	}

	return acc, true
}

// FoldForString applies a reducer to the Iterator.
func (i IteratorForString) FoldForString(init string, reducer func(acc string, item string) string) string {
	acc := init

	item := i.Next()
	for item.IsSome() {
		acc = reducer(acc, item.Unwrap())

		item = i.Next()
	}

	return acc
}

// TryFoldForString folds over the Iterator and stops if it reaches the end of the Iterator or got a Break (bool, interface{}).
func (i IteratorForString) TryFoldForString(init string, reducer func(acc string, item string) (string, bool)) (string, bool) {
	acc := init

	item := i.Next()
	for item.IsSome() {
		r, ok := reducer(acc, item.Unwrap())
		if !ok {
			return r, ok
		}

		acc = r
		item = i.Next()
	}

	return acc, true
}

// FoldForOptionForInt applies a reducer to the Iterator.
func (i IteratorForString) FoldForOptionForInt(init OptionForInt, reducer func(acc OptionForInt, item string) OptionForInt) OptionForInt {
	acc := init

	item := i.Next()
	for item.IsSome() {
		acc = reducer(acc, item.Unwrap())

		item = i.Next()
	}

	return acc
}

// TryFoldForOptionForInt folds over the Iterator and stops if it reaches the end of the Iterator or got a Break (bool, interface{}).
func (i IteratorForString) TryFoldForOptionForInt(init OptionForInt, reducer func(acc OptionForInt, item string) (OptionForInt, bool)) (OptionForInt, bool) {
	acc := init

	item := i.Next()
	for item.IsSome() {
		r, ok := reducer(acc, item.Unwrap())
		if !ok {
			return r, ok
		}

		acc = r
		item = i.Next()
	}

	return acc, true
}

// FoldForOptionForString applies a reducer to the Iterator.
func (i IteratorForString) FoldForOptionForString(init OptionForString, reducer func(acc OptionForString, item string) OptionForString) OptionForString {
	acc := init

	item := i.Next()
	for item.IsSome() {
		acc = reducer(acc, item.Unwrap())

		item = i.Next()
	}

	return acc
}

// TryFoldForOptionForString folds over the Iterator and stops if it reaches the end of the Iterator or got a Break (bool, interface{}).
func (i IteratorForString) TryFoldForOptionForString(init OptionForString, reducer func(acc OptionForString, item string) (OptionForString, bool)) (OptionForString, bool) {
	acc := init

	item := i.Next()
	for item.IsSome() {
		r, ok := reducer(acc, item.Unwrap())
		if !ok {
			return r, ok
		}

		acc = r
		item = i.Next()
	}

	return acc, true
}
