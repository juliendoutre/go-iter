// This file was automatically generated by genny.
// Any changes will be lost if this file is regenerated.
// see https://github.com/cheekybits/genny

package iter

type mapIterableForInt struct {
	iter   IterableForInt
	mapper func(item int) int
}

func (m *mapIterableForInt) Next() OptionForInt {
	item := m.iter.Next()
	if item.IsNone() {
		return NoneInt()
	}

	return SomeInt(m.mapper(item.Unwrap()))
}

var _ IterableForInt = &mapIterableForInt{}

type chainForInt struct {
	first  IterableForInt
	second IterableForInt
	flag   bool
}

func (c *chainForInt) Next() OptionForInt {
	if c.flag {
		return c.second.Next()
	}

	item := c.first.Next()
	if item.IsNone() {
		c.flag = true
		return c.second.Next()
	}

	return item
}

var _ IterableForInt = &chainForInt{}

// PairForInt is a 2-tuple.
type PairForInt struct {
	First  int
	Second int
}

type takeWhileForInt struct {
	iter      IterableForInt
	predicate func(item int) bool
	flag      bool
}

func (t *takeWhileForInt) Next() OptionForInt {
	if t.flag {
		return NoneInt()
	}

	item := t.iter.Next()
	if item.IsNone() {
		t.flag = true
		return NoneInt()
	}

	if !t.predicate(item.Unwrap()) {
		t.flag = true
		return NoneInt()
	}

	return item
}

var _ IterableForInt = &takeWhileForInt{}

type takeForInt struct {
	iter  IterableForInt
	max   uint
	count uint
	flag  bool
}

func (t *takeForInt) Next() OptionForInt {
	if t.flag {
		return NoneInt()
	}

	item := t.iter.Next()
	if item.IsNone() {
		t.flag = true
		return NoneInt()
	}

	if t.count >= t.max {
		t.flag = true
		return NoneInt()
	}

	t.count++

	return item
}

var _ IterableForInt = &takeForInt{}

type filterForInt struct {
	iter      *IteratorForInt
	predicate func(item int) bool
}

func (f *filterForInt) Next() OptionForInt {
	return f.iter.Find(f.predicate)
}

var _ IterableForInt = &filterForInt{}

type mapIterableForString struct {
	iter   IterableForString
	mapper func(item string) string
}

func (m *mapIterableForString) Next() OptionForString {
	item := m.iter.Next()
	if item.IsNone() {
		return NoneString()
	}

	return SomeString(m.mapper(item.Unwrap()))
}

var _ IterableForString = &mapIterableForString{}

type chainForString struct {
	first  IterableForString
	second IterableForString
	flag   bool
}

func (c *chainForString) Next() OptionForString {
	if c.flag {
		return c.second.Next()
	}

	item := c.first.Next()
	if item.IsNone() {
		c.flag = true
		return c.second.Next()
	}

	return item
}

var _ IterableForString = &chainForString{}

// PairForString is a 2-tuple.
type PairForString struct {
	First  string
	Second string
}

type takeWhileForString struct {
	iter      IterableForString
	predicate func(item string) bool
	flag      bool
}

func (t *takeWhileForString) Next() OptionForString {
	if t.flag {
		return NoneString()
	}

	item := t.iter.Next()
	if item.IsNone() {
		t.flag = true
		return NoneString()
	}

	if !t.predicate(item.Unwrap()) {
		t.flag = true
		return NoneString()
	}

	return item
}

var _ IterableForString = &takeWhileForString{}

type takeForString struct {
	iter  IterableForString
	max   uint
	count uint
	flag  bool
}

func (t *takeForString) Next() OptionForString {
	if t.flag {
		return NoneString()
	}

	item := t.iter.Next()
	if item.IsNone() {
		t.flag = true
		return NoneString()
	}

	if t.count >= t.max {
		t.flag = true
		return NoneString()
	}

	t.count++

	return item
}

var _ IterableForString = &takeForString{}

type filterForString struct {
	iter      *IteratorForString
	predicate func(item string) bool
}

func (f *filterForString) Next() OptionForString {
	return f.iter.Find(f.predicate)
}

var _ IterableForString = &filterForString{}
